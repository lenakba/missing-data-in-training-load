---
title: "Performing Multiple Imputation in R"
author: "Lena Kristin Bache-Mathiesen"
output:
  pdf_document:
    toc: yes
  word_document: default
  html_document:
    toc: yes
editor_options:
  chunk_output_type: console
---

# Introduction
This document is intended as a guide for imputing missing training load observations
using multiple imputation with predicted mean matching. 
Recommendations in Flexible Imputation of Missing Data by Stef van Buuren 
were followed in the missing data study, and will provide the basis for this guide.
For Ã¥ general guide on performing mulitple imputation in R, see:
https://stefvanbuuren.name/fimd/workflow.html 

# Preparation

First, load required packages.

```{r packages, warning=FALSE, echo = TRUE, message=FALSE}
library(mice) # Multivariate Imputation by Chained Equations (MICE) for multiple imputation
library(tidyverse) # readr for reading data, ggplot2 for figures ++
```

Next step is to load your data. Here we load 
the anonymised football data that are available as supplementary to the study.
We add fake injuries to the data with a predetermined relationship with training load.
We add missing to the datasets at random so we can impute them in the next step.
If you have your own dataset, you can simply load the data and skip ahead to the next chapter.

```{r load data, warning=FALSE, echo = TRUE, message=FALSE}
d_rpe_full = read_csv2("norwegian_premier_league_football_rpe_anon.csv")
d_td_full = read_csv2("norwegian_premier_league_football_td_anon.csv") %>% 
  rename(gps_td = total_distance_daily, gps_v4 = v4_distance_daily, 
         gps_v5 = v5_distance_daily, gps_pl = player_load_daily)

# we remove all inherent missing for sake of the example
d_rpe_nomissing = na.omit(d_rpe_full)
d_td_nomissing = na.omit(d_td_full)
```

We add some fake injuries with a fake relationship with training load.

```{r injuries, warning=FALSE, echo = TRUE, message=FALSE}
# logistic function
log_reg = function(tl_coef){
  res = 1 / (1 + exp(-tl_coef))
  res
}

# linear logistic regression function
# where the level of sRPE effects injury probability
inj_probability_srpe = function(srpe){
  y = log_reg(-2 + 0.003*srpe) 
  y
}

# create fake injuries
d_srpe = d_rpe_nomissing %>% 
  mutate(srpe = duration*rpe,
         inj_prop = inj_probability_srpe(srpe), 
         injury = rbinom(length(inj_prop), 1, prob = inj_prop))

# remove variables we in theory wouldn't know about
# in a real life situation
d_srpe = d_srpe %>% dplyr::select(-inj_prop, -srpe)

# repeat for total distance
inj_probability_td = function(gps_td){
  y = log_reg(-2 + 0.0003*gps_td) 
  y
}

d_td = d_td_nomissing %>% 
  mutate(inj_prop = inj_probability_td(gps_td), 
         injury = rbinom(length(inj_prop), 1, prob = inj_prop))

keyvars = c("p_id", "training_date", "mc_day", "week_nr")
d_td = d_td %>% select(all_of(keyvars), injury, starts_with("gps"), srpe)
```

Add missing to the training load variables.

```{r missing, warning=FALSE, echo = TRUE, message=FALSE}
# adding missing for our example
# under missing completely at random
add_mcar_rpe = function(d, missing_prop){
  n_values = nrow(d)
  d = d %>% rownames_to_column()
  random_spots_rpe = sample(1:n_values, round(missing_prop*n_values))
  random_spots_min = sample(1:n_values, round(missing_prop*n_values))
  d = d %>% mutate(rpe = ifelse(rowname %in% random_spots_rpe, NA, rpe),
                   duration = ifelse(rowname %in% random_spots_min, NA, duration)) %>% 
      dplyr::select(-rowname)
  d
}

# adding 25% missing randomly distributed between duration and rpe
d_rpe_missing = add_mcar_rpe(d_srpe, 0.25)

add_mcar_td = function(d, missing_prop){
  n_values = nrow(d)
  d = d %>% rownames_to_column()
  random_spots_td = sample(1:n_values, round(missing_prop*n_values))
  d = d %>% mutate(gps_td = ifelse(rowname %in% random_spots_td, NA, gps_td)) %>% 
      dplyr::select(-rowname)
  d
}

# adding 25% missing in total distance
d_td_missing = add_mcar_td(d_td, 0.25)
```

# Imputing session RPE

sRPE is a little bit trickier than the GPS data since 
it is a derived variable. We tested different ways to impute sRPE
and found out that the best method (the one with least bias)
was imputing duration and rpe before calculating sRPE (Impute, then transform).

Imputation using multiple imputation and predicted mean matching code below.
The default method in `mice` is PMM, and the default number of datasets is 5.
For PMM, the default number of donors is also 5.
However, you can change the number of datasets with the argument `m`

```{r mi_pmm, warning=FALSE, echo = TRUE, message=FALSE}
mids.pmm = mice(d_rpe_missing, print = FALSE, seed = 1234, m = 5)
```

Then, we need to tell R to derive the sRPE in our imputed objects, 
which is done here:

```{r mulitplication, warning=FALSE, echo = TRUE, message=FALSE}
imp.pmm = mice::complete(mids.pmm, "long", include = TRUE)
imp.pmm$srpe = with(imp.pmm, rpe*duration)
mids.itt.pmm = as.mids(imp.pmm)
```

It can be a good idea to check whether 
the imputed data follows the same distribution
as the real data. The `mice` package comes
with a very handy `densityplot()`
function that does this for us. Red are the imputed datasets,
blue are the original data. 

```{r imp_vs_real, warning=FALSE, echo = TRUE, message=FALSE}
densityplot(x=mids.itt.pmm, data = ~rpe + duration)
```

We can then fit our logistic regression model, 
with injury as the response variable and
sRPE the independent variable,
using this mids object.
The `pool()` command automatically
pools the fitted estimates into one summary
using Rubin's rules. 

```{r fit_srpe, warning=FALSE, echo = TRUE, message=FALSE}
fit.pmm =  with(mids.itt.pmm, glm(injury ~ srpe, family = binomial))
fit.pmm.pooled = pool(fit.pmm)
summary(fit.pmm.pooled, "all", conf.int = TRUE)
```

If we don't want to use the  `mice` package to fit our imputed datasets, 
we can make a list out of the imputed data and perform our model-fitting on each
dataset in the list manually.

We could fit any kind of model using the regular `glm()`
command from base R. Here we provide an example 
using a mixed model with a random intercept per player,
with the `glmer()` command from the `lme4` package.
The `lme4` package is not entirely compatible with the 
`MICE` package, so we'd have to do this if we wanted to 
run a mixed model.

Note that the `map()` function from 
the `purrr` package provided by `tidyverse`
ensures that the model is run on each dataset in the list.

```{r list_srpe, warning=FALSE, echo = TRUE, message=FALSE}
list.pmm = mice::complete(mids.itt.pmm, "all")
# the first dataset in the list is the original, unimputed data.
# we remove this first.
list.pmm = list.pmm[-1]
# load the mixed model package and run our mixed logistic regression model
library(lme4)
fit_mixed = list.pmm %>% map(glmer, formula = injury ~ srpe + (1 | p_id), family = "binomial") 
```

If you want to look at the imputed datasets 
in a regular dataframe, we can convert our 
list with the following code using the `tidyverse` package.

The `imap` command adds an index to each
dataset so we can tell which row belongs to which
replicated dataset in the final data.frame. 

After running the code below, `d.pmm` can be 
used as any ordinary dataframe object.

```{r imps_srpe, warning=FALSE, echo = TRUE, message=FALSE}
list.pmm = list.pmm %>% imap(., ~mutate(., dataset_n = .y)) 
d.pmm = list.pmm %>%  bind_rows()
```







